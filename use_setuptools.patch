diff -rupN a/aksetup_helper.py b/aksetup_helper.py
--- a/aksetup_helper.py	2012-12-16 02:56:27.000000000 +0100
+++ b/aksetup_helper.py	2013-06-10 17:52:22.000000000 +0200
@@ -1,10 +1,7 @@
-# dealings with ez_setup ------------------------------------------------------
-import distribute_setup
-distribute_setup.use_setuptools()
-
-import setuptools
+import setuptools  # noqa
 from setuptools import Extension
 
+
 def count_down_delay(delay):
     from time import sleep
     import sys
@@ -15,31 +12,11 @@ def count_down_delay(delay):
         sleep(1)
     print("")
 
-
-
-
-if not hasattr(setuptools, "_distribute"):
-    print("-------------------------------------------------------------------------")
-    print("Setuptools conflict detected.")
-    print("-------------------------------------------------------------------------")
-    print("When I imported setuptools, I did not get the distribute version of")
-    print("setuptools, which is troubling--this package really wants to be used")
-    print("with distribute rather than the old setuptools package. More than likely,")
-    print("you have both distribute and setuptools installed, which is bad.")
-    print("")
-    print("See this page for more information:")
-    print("http://wiki.tiker.net/DistributeVsSetuptools")
-    print("-------------------------------------------------------------------------")
-    print("I will continue after a short while, fingers crossed.")
-    print("Hit Ctrl-C now if you'd like to think about the situation.")
-    print("-------------------------------------------------------------------------")
-
-    count_down_delay(delay=10)
+DASH_SEPARATOR = 75 * "-"
 
 
 def setup(*args, **kwargs):
     from setuptools import setup
-    import traceback
     try:
         setup(*args, **kwargs)
     except KeyboardInterrupt:
@@ -47,14 +24,13 @@ def setup(*args, **kwargs):
     except SystemExit:
         raise
     except:
-        print ("----------------------------------------------------------------------------")
-        print ("Sorry, your build failed. Try rerunning configure.py with different options.")
-        print ("----------------------------------------------------------------------------")
+        print(DASH_SEPARATOR)
+        print("Sorry, your build failed. Try rerunning configure.py with "
+                "different options.")
+        print(DASH_SEPARATOR)
         raise
 
 
-
-
 class NumpyExtension(Extension):
     # nicked from
     # http://mail.python.org/pipermail/distutils-sig/2007-September/008253.html
@@ -62,7 +38,7 @@ class NumpyExtension(Extension):
     def __init__(self, *args, **kwargs):
         Extension.__init__(self, *args, **kwargs)
         self._include_dirs = self.include_dirs
-        del self.include_dirs # restore overwritten property
+        del self.include_dirs  # restore overwritten property
 
     def get_numpy_incpath(self):
         from imp import find_module
@@ -73,29 +49,20 @@ class NumpyExtension(Extension):
 
     def get_include_dirs(self):
         return self._include_dirs + [self.get_numpy_incpath()]
+
     def set_include_dirs(self, value):
         self._include_dirs = value
+
     def del_include_dirs(self):
         pass
 
     include_dirs = property(get_include_dirs, set_include_dirs, del_include_dirs)
 
 
-
-
 class PyUblasExtension(NumpyExtension):
     def get_module_include_path(self, name):
-        from imp import find_module
-        file, pathname, descr = find_module(name)
-        from os.path import join, exists
-        installed_path = join(pathname, "..", "include")
-        development_path = join(pathname, "..", "src", "cpp")
-        if exists(installed_path):
-            return installed_path
-        elif exists(development_path):
-            return development_path
-        else:
-            raise RuntimeError("could not find C include path for module '%s'" % name)
+        from pkg_resources import Requirement, resource_filename
+        return resource_filename(Requirement.parse(name), "%s/include" % name)
 
     @property
     def include_dirs(self):
@@ -105,8 +72,6 @@ class PyUblasExtension(NumpyExtension):
                 ]
 
 
-
-
 class HedgeExtension(PyUblasExtension):
     @property
     def include_dirs(self):
@@ -117,9 +82,8 @@ class HedgeExtension(PyUblasExtension):
                 ]
 
 
+# {{{ tools
 
-
-# tools -----------------------------------------------------------------------
 def flatten(list):
     """For an iterable of sub-iterables, generate each member of each
     sub-iterable in turn, i.e. a flattened version of that super-iterable.
@@ -131,16 +95,15 @@ def flatten(list):
             yield j
 
 
-
-
 def humanize(sym_str):
     words = sym_str.lower().replace("_", " ").split(" ")
     return " ".join([word.capitalize() for word in words])
 
+# }}}
 
 
+# {{{ siteconf handling
 
-# siteconf handling -----------------------------------------------------------
 def get_config(schema=None, warn_about_no_config=True):
     if schema is None:
         from setup import get_config_schema
@@ -168,8 +131,6 @@ def get_config(schema=None, warn_about_n
     return expand_options(schema.read_config())
 
 
-
-
 def hack_distutils(debug=False, fast_link=True, what_opt=3):
     # hack distutils.sysconfig to eliminate debug flags
     # stolen from mpi4py
@@ -211,9 +172,11 @@ def hack_distutils(debug=False, fast_lin
                             ['-Wl,-O'])
                     cvars[varname] = str.join(' ', ldsharedflags)
 
+# }}}
+
 
+# {{{ configure guts
 
-# configure guts --------------------------------------------------------------
 def default_or(a, b):
     if a is None:
         return b
@@ -221,7 +184,6 @@ def default_or(a, b):
         return a
 
 
-
 def expand_str(s, options):
     import re
 
@@ -237,6 +199,7 @@ def expand_str(s, options):
 
     return re.subn(r"\$\{([a-zA-Z0-9_]+)\}", my_repl, s)[0]
 
+
 def expand_value(v, options):
     if isinstance(v, str):
         return expand_str(v, options)
@@ -260,10 +223,6 @@ def expand_options(options):
             (k, expand_value(v, options)) for k, v in options.items())
 
 
-
-
-
-
 class ConfigSchema:
     def __init__(self, options, conf_file="siteconf.py", conf_dir="."):
         self.optdict = dict((opt.name, opt) for opt in options)
@@ -416,12 +375,6 @@ class ConfigSchema:
                 for opt in self.options)
 
 
-
-
-
-
-
-
 class Option(object):
     def __init__(self, name, default=None, help=None):
         self.name = name
@@ -456,10 +409,9 @@ class Option(object):
     def take_from_configparser(self, options):
         return getattr(options, self.name)
 
+
 class Switch(Option):
     def add_to_configparser(self, parser, default=None):
-        option = self.as_option()
-
         if not isinstance(self.default, bool):
             raise ValueError("Switch options must have a default")
 
@@ -481,6 +433,7 @@ class Switch(Option):
             default=default,
             action=action)
 
+
 class StringListOption(Option):
     def value_to_str(self, default):
         if default is None:
@@ -512,25 +465,36 @@ class IncludeDir(StringListOption):
                 help=help or ("Include directories for %s"
                 % (human_name or humanize(lib_name))))
 
+
 class LibraryDir(StringListOption):
     def __init__(self, lib_name, default=None, human_name=None, help=None):
         StringListOption.__init__(self, "%s_LIB_DIR" % lib_name, default,
                 help=help or ("Library directories for %s"
                 % (human_name or humanize(lib_name))))
 
+
 class Libraries(StringListOption):
     def __init__(self, lib_name, default=None, human_name=None, help=None):
         StringListOption.__init__(self, "%s_LIBNAME" % lib_name, default,
                 help=help or ("Library names for %s (without lib or .so)"
                 % (human_name or humanize(lib_name))))
 
+
 class BoostLibraries(Libraries):
-    def __init__(self, lib_base_name):
+    def __init__(self, lib_base_name, default_lib_name=None):
+        if default_lib_name is None:
+            if lib_base_name == "python":
+                import sys
+                default_lib_name = "boost_python3"
+            else:
+                default_lib_name = "boost_%s" % lib_base_name
+
         Libraries.__init__(self, "BOOST_%s" % lib_base_name.upper(),
-                ["boost_%s" % lib_base_name],
+                [default_lib_name],
                 help="Library names for Boost C++ %s library (without lib or .so)"
                     % humanize(lib_base_name))
 
+
 def set_up_shipped_boost_if_requested(project_name, conf):
     """Set up the package to use a shipped version of Boost.
 
@@ -542,14 +506,14 @@ def set_up_shipped_boost_if_requested(pr
 
     if conf["USE_SHIPPED_BOOST"]:
         if not exists("bpl-subset/bpl_subset/boost/version.hpp"):
-            print("------------------------------------------------------------------------")
-            print("The shipped Boost library was not found, but USE_SHIPPED_BOOST is True.")
+            print(DASH_SEPARATOR)
+            print("The shipped Boost library was not found, but "
+                    "USE_SHIPPED_BOOST is True.")
             print("(The files should be under bpl-subset/.)")
-            print("------------------------------------------------------------------------")
+            print(DASH_SEPARATOR)
             print("If you got this package from git, you probably want to do")
             print("")
-            print(" $ git submodule init")
-            print(" $ git submodule update")
+            print(" $ git submodule update --init")
             print("")
             print("to fetch what you are presently missing. If you got this from")
             print("a distributed package on the net, that package is broken and")
@@ -557,7 +521,7 @@ def set_up_shipped_boost_if_requested(pr
             print("to try and see if the build succeeds that way, but in the long")
             print("run you might want to either get the missing bits or turn")
             print("'USE_SHIPPED_BOOST' off.")
-            print("------------------------------------------------------------------------")
+            print(DASH_SEPARATOR)
             conf["USE_SHIPPED_BOOST"] = False
 
             count_down_delay(delay=10)
@@ -574,7 +538,7 @@ def set_up_shipped_boost_if_requested(pr
                 + glob("bpl-subset/bpl_subset/libs/*/*.cpp"))
 
         # make sure next line succeeds even on Windows
-        source_files = [f.replace("\\","/") for f in source_files]
+        source_files = [f.replace("\\", "/") for f in source_files]
 
         source_files = [f for f in source_files
                 if not f.startswith("bpl-subset/bpl_subset/libs/thread/src")]
@@ -627,11 +591,6 @@ def make_boost_base_options():
         ]
 
 
-
-
-
-
-
 def configure_frontend():
     from optparse import OptionParser
 
@@ -657,7 +616,8 @@ def configure_frontend():
             help="Ignored")
     parser.add_option("--enable-shared", help="Ignored", action="store_false")
     parser.add_option("--disable-static", help="Ignored", action="store_false")
-    parser.add_option("--update-user", help="Update user config file (%s)" % schema.user_conf_file,
+    parser.add_option("--update-user",
+            help="Update user config file (%s)" % schema.user_conf_file,
             action="store_true")
     parser.add_option("--update-global",
             help="Update global config file (%s)" % schema.global_conf_file,
@@ -684,8 +644,6 @@ def configure_frontend():
         substitute(substs, "Makefile")
 
 
-
-
 def substitute(substitutions, fname):
     import re
     var_re = re.compile(r"\$\{([A-Za-z_0-9]+)\}")
@@ -713,10 +671,11 @@ def substitute(substitutions, fname):
                 else:
                     subst = '"%s"' % subst
 
-                l = l[:match.start()] + subst  + l[match.end():]
+                l = l[:match.start()] + subst + l[match.end():]
                 made_change = True
         new_lines.append(l)
-    new_lines.insert(1, "# DO NOT EDIT THIS FILE -- it was generated by configure.py\n")
+    new_lines.insert(1, "# DO NOT EDIT THIS FILE -- "
+            "it was generated by configure.py\n")
     import sys
     new_lines.insert(2, "# %s\n" % (" ".join(sys.argv)))
     open(fname, "w").write("".join(new_lines))
@@ -726,47 +685,48 @@ def substitute(substitutions, fname):
     chmod(fname, infile_stat_res.st_mode)
 
 
-
-
-def check_git_submodules():
-    from os.path import isdir
-    if not isdir(".git"):
-        # not a git repository
-        return
-
+def _run_git_command(cmd):
     git_error = None
     from subprocess import Popen, PIPE
     try:
-        popen = Popen(["git", "--version"], stdout=PIPE)
-        stdout_data, _ = popen.communicate()
+        popen = Popen(["git"] + cmd, stdout=PIPE)
+        stdout, stderr = popen.communicate()
         if popen.returncode != 0:
-            git_error = "git returned error code %d" % popen.returncode
+            git_error = "git returned error code %d: %s" % (popen.returncode, stderr)
     except OSError:
-        git_error = "(os error, likely git not found)"
+        git_error = "(OS error, likely git not found)"
 
     if git_error is not None:
-        print("-------------------------------------------------------------------------")
+        print(DASH_SEPARATOR)
         print("Trouble invoking git")
-        print("-------------------------------------------------------------------------")
+        print(DASH_SEPARATOR)
         print("The package directory appears to be a git repository, but I could")
         print("not invoke git to check whether my submodules are up to date.")
         print("")
         print("The error was:")
         print(git_error)
         print("Hit Ctrl-C now if you'd like to think about the situation.")
-        print("-------------------------------------------------------------------------")
+        print(DASH_SEPARATOR)
         count_down_delay(delay=5)
+    return stdout.decode("ascii"), git_error
+
+
+def check_git_submodules():
+    from os.path import isdir
+    if not isdir(".git"):
+        # not a git repository
+        return
+    if isdir("../.repo"):
+        # assume repo is in charge and bail
         return
 
-    popen = Popen(["git", "submodule", "status"], stdout=PIPE)
-    stdout_data, _ = popen.communicate()
-    stdout_data = stdout_data.decode("ascii")
-    if popen.returncode != 0:
-        git_error = "git returned error code %d" % popen.returncode
+    stdout, git_error = _run_git_command(["submodule", "status"])
+    if git_error is not None:
+        return
 
     pkg_warnings = []
 
-    lines = stdout_data.split("\n")
+    lines = stdout.split("\n")
     for l in lines:
         if not l.strip():
             continue
@@ -779,10 +739,10 @@ def check_git_submodules():
             continue
 
         if status == "+":
-            pkg_warnings.append("version of '%s' is not what this outer package wants"
-                    % package)
+            pkg_warnings.append("version of '%s' is not what this "
+                    "outer package wants" % package)
         elif status == "-":
-            pkg_warnings.append("subpackage '%s' is not initialized" 
+            pkg_warnings.append("subpackage '%s' is not initialized"
                     % package)
         elif status == " ":
             pass
@@ -791,36 +751,36 @@ def check_git_submodules():
                     % package)
 
     if pkg_warnings:
-            print("-------------------------------------------------------------------------")
+            print(DASH_SEPARATOR)
             print("git submodules are not up-to-date or in odd state")
-            print("-------------------------------------------------------------------------")
+            print(DASH_SEPARATOR)
             print("If this makes no sense, you probably want to say")
             print("")
-            print(" $ git submodule init")
-            print(" $ git submodule update")
+            print(" $ git submodule update --init")
             print("")
-            print("to fetch what you are presently missing and move on with your life.")
-            print("If you got this from a distributed package on the net, that package is")
-            print("broken and should be fixed. Please inform whoever gave you this package.")
+            print("to fetch what you are presently missing and "
+                    "move on with your life.")
+            print("If you got this from a distributed package on the "
+                    "net, that package is")
+            print("broken and should be fixed. Please inform whoever "
+                    "gave you this package.")
             print("")
             print("These issues were found:")
             for w in pkg_warnings:
                 print("  %s" % w)
             print("")
-            print("I will try to continue after a short wait, fingers crossed.")
-            print("-------------------------------------------------------------------------")
+            print("I will try to initialize the submodules for you "
+                    "after a short wait.")
+            print(DASH_SEPARATOR)
             print("Hit Ctrl-C now if you'd like to think about the situation.")
-            print("-------------------------------------------------------------------------")
+            print(DASH_SEPARATOR)
 
             from os.path import exists
             if not exists(".dirty-git-ok"):
                 count_down_delay(delay=10)
-
-
-
-
-
-
-
-
-
+                stdout, git_error = _run_git_command(
+                        ["submodule", "update", "--init"])
+                if git_error is None:
+                    print(DASH_SEPARATOR)
+                    print("git submodules initialized successfully")
+                    print(DASH_SEPARATOR)
diff -rupN a/distribute_setup.py b/distribute_setup.py
--- a/distribute_setup.py	2012-08-30 00:28:33.000000000 +0200
+++ b/distribute_setup.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,485 +0,0 @@
-#!python
-"""Bootstrap distribute installation
-
-If you want to use setuptools in your package's setup.py, just include this
-file in the same directory with it, and add this to the top of your setup.py::
-
-    from distribute_setup import use_setuptools
-    use_setuptools()
-
-If you want to require a specific version of setuptools, set a download
-mirror, or use an alternate download directory, you can do so by supplying
-the appropriate options to ``use_setuptools()``.
-
-This file can also be run as a script to install or upgrade setuptools.
-"""
-import os
-import sys
-import time
-import fnmatch
-import tempfile
-import tarfile
-from distutils import log
-
-try:
-    from site import USER_SITE
-except ImportError:
-    USER_SITE = None
-
-try:
-    import subprocess
-
-    def _python_cmd(*args):
-        args = (sys.executable,) + args
-        return subprocess.call(args) == 0
-
-except ImportError:
-    # will be used for python 2.3
-    def _python_cmd(*args):
-        args = (sys.executable,) + args
-        # quoting arguments if windows
-        if sys.platform == 'win32':
-            def quote(arg):
-                if ' ' in arg:
-                    return '"%s"' % arg
-                return arg
-            args = [quote(arg) for arg in args]
-        return os.spawnl(os.P_WAIT, sys.executable, *args) == 0
-
-DEFAULT_VERSION = "0.6.19"
-DEFAULT_URL = "http://pypi.python.org/packages/source/d/distribute/"
-SETUPTOOLS_FAKED_VERSION = "0.6c11"
-
-SETUPTOOLS_PKG_INFO = """\
-Metadata-Version: 1.0
-Name: setuptools
-Version: %s
-Summary: xxxx
-Home-page: xxx
-Author: xxx
-Author-email: xxx
-License: xxx
-Description: xxx
-""" % SETUPTOOLS_FAKED_VERSION
-
-
-def _install(tarball):
-    # extracting the tarball
-    tmpdir = tempfile.mkdtemp()
-    log.warn('Extracting in %s', tmpdir)
-    old_wd = os.getcwd()
-    try:
-        os.chdir(tmpdir)
-        tar = tarfile.open(tarball)
-        _extractall(tar)
-        tar.close()
-
-        # going in the directory
-        subdir = os.path.join(tmpdir, os.listdir(tmpdir)[0])
-        os.chdir(subdir)
-        log.warn('Now working in %s', subdir)
-
-        # installing
-        log.warn('Installing Distribute')
-        if not _python_cmd('setup.py', 'install'):
-            log.warn('Something went wrong during the installation.')
-            log.warn('See the error message above.')
-    finally:
-        os.chdir(old_wd)
-
-
-def _build_egg(egg, tarball, to_dir):
-    # extracting the tarball
-    tmpdir = tempfile.mkdtemp()
-    log.warn('Extracting in %s', tmpdir)
-    old_wd = os.getcwd()
-    try:
-        os.chdir(tmpdir)
-        tar = tarfile.open(tarball)
-        _extractall(tar)
-        tar.close()
-
-        # going in the directory
-        subdir = os.path.join(tmpdir, os.listdir(tmpdir)[0])
-        os.chdir(subdir)
-        log.warn('Now working in %s', subdir)
-
-        # building an egg
-        log.warn('Building a Distribute egg in %s', to_dir)
-        _python_cmd('setup.py', '-q', 'bdist_egg', '--dist-dir', to_dir)
-
-    finally:
-        os.chdir(old_wd)
-    # returning the result
-    log.warn(egg)
-    if not os.path.exists(egg):
-        raise IOError('Could not build the egg.')
-
-
-def _do_download(version, download_base, to_dir, download_delay):
-    egg = os.path.join(to_dir, 'distribute-%s-py%d.%d.egg'
-                       % (version, sys.version_info[0], sys.version_info[1]))
-    if not os.path.exists(egg):
-        tarball = download_setuptools(version, download_base,
-                                      to_dir, download_delay)
-        _build_egg(egg, tarball, to_dir)
-    sys.path.insert(0, egg)
-    import setuptools
-    setuptools.bootstrap_install_from = egg
-
-
-def use_setuptools(version=DEFAULT_VERSION, download_base=DEFAULT_URL,
-                   to_dir=os.curdir, download_delay=15, no_fake=True):
-    # making sure we use the absolute path
-    to_dir = os.path.abspath(to_dir)
-    was_imported = 'pkg_resources' in sys.modules or \
-        'setuptools' in sys.modules
-    try:
-        try:
-            import pkg_resources
-            if not hasattr(pkg_resources, '_distribute'):
-                if not no_fake:
-                    _fake_setuptools()
-                raise ImportError
-        except ImportError:
-            return _do_download(version, download_base, to_dir, download_delay)
-        try:
-            pkg_resources.require("distribute>="+version)
-            return
-        except pkg_resources.VersionConflict:
-            e = sys.exc_info()[1]
-            if was_imported:
-                sys.stderr.write(
-                "The required version of distribute (>=%s) is not available,\n"
-                "and can't be installed while this script is running. Please\n"
-                "install a more recent version first, using\n"
-                "'easy_install -U distribute'."
-                "\n\n(Currently using %r)\n" % (version, e.args[0]))
-                sys.exit(2)
-            else:
-                del pkg_resources, sys.modules['pkg_resources']    # reload ok
-                return _do_download(version, download_base, to_dir,
-                                    download_delay)
-        except pkg_resources.DistributionNotFound:
-            return _do_download(version, download_base, to_dir,
-                                download_delay)
-    finally:
-        if not no_fake:
-            _create_fake_setuptools_pkg_info(to_dir)
-
-def download_setuptools(version=DEFAULT_VERSION, download_base=DEFAULT_URL,
-                        to_dir=os.curdir, delay=15):
-    """Download distribute from a specified location and return its filename
-
-    `version` should be a valid distribute version number that is available
-    as an egg for download under the `download_base` URL (which should end
-    with a '/'). `to_dir` is the directory where the egg will be downloaded.
-    `delay` is the number of seconds to pause before an actual download
-    attempt.
-    """
-    # making sure we use the absolute path
-    to_dir = os.path.abspath(to_dir)
-    try:
-        from urllib.request import urlopen
-    except ImportError:
-        from urllib2 import urlopen
-    tgz_name = "distribute-%s.tar.gz" % version
-    url = download_base + tgz_name
-    saveto = os.path.join(to_dir, tgz_name)
-    src = dst = None
-    if not os.path.exists(saveto):  # Avoid repeated downloads
-        try:
-            log.warn("Downloading %s", url)
-            src = urlopen(url)
-            # Read/write all in one block, so we don't create a corrupt file
-            # if the download is interrupted.
-            data = src.read()
-            dst = open(saveto, "wb")
-            dst.write(data)
-        finally:
-            if src:
-                src.close()
-            if dst:
-                dst.close()
-    return os.path.realpath(saveto)
-
-def _no_sandbox(function):
-    def __no_sandbox(*args, **kw):
-        try:
-            from setuptools.sandbox import DirectorySandbox
-            if not hasattr(DirectorySandbox, '_old'):
-                def violation(*args):
-                    pass
-                DirectorySandbox._old = DirectorySandbox._violation
-                DirectorySandbox._violation = violation
-                patched = True
-            else:
-                patched = False
-        except ImportError:
-            patched = False
-
-        try:
-            return function(*args, **kw)
-        finally:
-            if patched:
-                DirectorySandbox._violation = DirectorySandbox._old
-                del DirectorySandbox._old
-
-    return __no_sandbox
-
-def _patch_file(path, content):
-    """Will backup the file then patch it"""
-    existing_content = open(path).read()
-    if existing_content == content:
-        # already patched
-        log.warn('Already patched.')
-        return False
-    log.warn('Patching...')
-    _rename_path(path)
-    f = open(path, 'w')
-    try:
-        f.write(content)
-    finally:
-        f.close()
-    return True
-
-_patch_file = _no_sandbox(_patch_file)
-
-def _same_content(path, content):
-    return open(path).read() == content
-
-def _rename_path(path):
-    new_name = path + '.OLD.%s' % time.time()
-    log.warn('Renaming %s into %s', path, new_name)
-    os.rename(path, new_name)
-    return new_name
-
-def _remove_flat_installation(placeholder):
-    if not os.path.isdir(placeholder):
-        log.warn('Unknown installation at %s', placeholder)
-        return False
-    found = False
-    for file in os.listdir(placeholder):
-        if fnmatch.fnmatch(file, 'setuptools*.egg-info'):
-            found = True
-            break
-    if not found:
-        log.warn('Could not locate setuptools*.egg-info')
-        return
-
-    log.warn('Removing elements out of the way...')
-    pkg_info = os.path.join(placeholder, file)
-    if os.path.isdir(pkg_info):
-        patched = _patch_egg_dir(pkg_info)
-    else:
-        patched = _patch_file(pkg_info, SETUPTOOLS_PKG_INFO)
-
-    if not patched:
-        log.warn('%s already patched.', pkg_info)
-        return False
-    # now let's move the files out of the way
-    for element in ('setuptools', 'pkg_resources.py', 'site.py'):
-        element = os.path.join(placeholder, element)
-        if os.path.exists(element):
-            _rename_path(element)
-        else:
-            log.warn('Could not find the %s element of the '
-                     'Setuptools distribution', element)
-    return True
-
-_remove_flat_installation = _no_sandbox(_remove_flat_installation)
-
-def _after_install(dist):
-    log.warn('After install bootstrap.')
-    placeholder = dist.get_command_obj('install').install_purelib
-    _create_fake_setuptools_pkg_info(placeholder)
-
-def _create_fake_setuptools_pkg_info(placeholder):
-    if not placeholder or not os.path.exists(placeholder):
-        log.warn('Could not find the install location')
-        return
-    pyver = '%s.%s' % (sys.version_info[0], sys.version_info[1])
-    setuptools_file = 'setuptools-%s-py%s.egg-info' % \
-            (SETUPTOOLS_FAKED_VERSION, pyver)
-    pkg_info = os.path.join(placeholder, setuptools_file)
-    if os.path.exists(pkg_info):
-        log.warn('%s already exists', pkg_info)
-        return
-
-    log.warn('Creating %s', pkg_info)
-    f = open(pkg_info, 'w')
-    try:
-        f.write(SETUPTOOLS_PKG_INFO)
-    finally:
-        f.close()
-
-    pth_file = os.path.join(placeholder, 'setuptools.pth')
-    log.warn('Creating %s', pth_file)
-    f = open(pth_file, 'w')
-    try:
-        f.write(os.path.join(os.curdir, setuptools_file))
-    finally:
-        f.close()
-
-_create_fake_setuptools_pkg_info = _no_sandbox(_create_fake_setuptools_pkg_info)
-
-def _patch_egg_dir(path):
-    # let's check if it's already patched
-    pkg_info = os.path.join(path, 'EGG-INFO', 'PKG-INFO')
-    if os.path.exists(pkg_info):
-        if _same_content(pkg_info, SETUPTOOLS_PKG_INFO):
-            log.warn('%s already patched.', pkg_info)
-            return False
-    _rename_path(path)
-    os.mkdir(path)
-    os.mkdir(os.path.join(path, 'EGG-INFO'))
-    pkg_info = os.path.join(path, 'EGG-INFO', 'PKG-INFO')
-    f = open(pkg_info, 'w')
-    try:
-        f.write(SETUPTOOLS_PKG_INFO)
-    finally:
-        f.close()
-    return True
-
-_patch_egg_dir = _no_sandbox(_patch_egg_dir)
-
-def _before_install():
-    log.warn('Before install bootstrap.')
-    _fake_setuptools()
-
-
-def _under_prefix(location):
-    if 'install' not in sys.argv:
-        return True
-    args = sys.argv[sys.argv.index('install')+1:]
-    for index, arg in enumerate(args):
-        for option in ('--root', '--prefix'):
-            if arg.startswith('%s=' % option):
-                top_dir = arg.split('root=')[-1]
-                return location.startswith(top_dir)
-            elif arg == option:
-                if len(args) > index:
-                    top_dir = args[index+1]
-                    return location.startswith(top_dir)
-        if arg == '--user' and USER_SITE is not None:
-            return location.startswith(USER_SITE)
-    return True
-
-
-def _fake_setuptools():
-    log.warn('Scanning installed packages')
-    try:
-        import pkg_resources
-    except ImportError:
-        # we're cool
-        log.warn('Setuptools or Distribute does not seem to be installed.')
-        return
-    ws = pkg_resources.working_set
-    try:
-        setuptools_dist = ws.find(pkg_resources.Requirement.parse('setuptools',
-                                  replacement=False))
-    except TypeError:
-        # old distribute API
-        setuptools_dist = ws.find(pkg_resources.Requirement.parse('setuptools'))
-
-    if setuptools_dist is None:
-        log.warn('No setuptools distribution found')
-        return
-    # detecting if it was already faked
-    setuptools_location = setuptools_dist.location
-    log.warn('Setuptools installation detected at %s', setuptools_location)
-
-    # if --root or --preix was provided, and if
-    # setuptools is not located in them, we don't patch it
-    if not _under_prefix(setuptools_location):
-        log.warn('Not patching, --root or --prefix is installing Distribute'
-                 ' in another location')
-        return
-
-    # let's see if its an egg
-    if not setuptools_location.endswith('.egg'):
-        log.warn('Non-egg installation')
-        res = _remove_flat_installation(setuptools_location)
-        if not res:
-            return
-    else:
-        log.warn('Egg installation')
-        pkg_info = os.path.join(setuptools_location, 'EGG-INFO', 'PKG-INFO')
-        if (os.path.exists(pkg_info) and
-            _same_content(pkg_info, SETUPTOOLS_PKG_INFO)):
-            log.warn('Already patched.')
-            return
-        log.warn('Patching...')
-        # let's create a fake egg replacing setuptools one
-        res = _patch_egg_dir(setuptools_location)
-        if not res:
-            return
-    log.warn('Patched done.')
-    _relaunch()
-
-
-def _relaunch():
-    log.warn('Relaunching...')
-    # we have to relaunch the process
-    # pip marker to avoid a relaunch bug
-    if sys.argv[:3] == ['-c', 'install', '--single-version-externally-managed']:
-        sys.argv[0] = 'setup.py'
-    args = [sys.executable] + sys.argv
-    sys.exit(subprocess.call(args))
-
-
-def _extractall(self, path=".", members=None):
-    """Extract all members from the archive to the current working
-       directory and set owner, modification time and permissions on
-       directories afterwards. `path' specifies a different directory
-       to extract to. `members' is optional and must be a subset of the
-       list returned by getmembers().
-    """
-    import copy
-    import operator
-    from tarfile import ExtractError
-    directories = []
-
-    if members is None:
-        members = self
-
-    for tarinfo in members:
-        if tarinfo.isdir():
-            # Extract directories with a safe mode.
-            directories.append(tarinfo)
-            tarinfo = copy.copy(tarinfo)
-            tarinfo.mode = 448 # decimal for oct 0700
-        self.extract(tarinfo, path)
-
-    # Reverse sort directories.
-    if sys.version_info < (2, 4):
-        def sorter(dir1, dir2):
-            return cmp(dir1.name, dir2.name)
-        directories.sort(sorter)
-        directories.reverse()
-    else:
-        directories.sort(key=operator.attrgetter('name'), reverse=True)
-
-    # Set correct owner, mtime and filemode on directories.
-    for tarinfo in directories:
-        dirpath = os.path.join(path, tarinfo.name)
-        try:
-            self.chown(tarinfo, dirpath)
-            self.utime(tarinfo, dirpath)
-            self.chmod(tarinfo, dirpath)
-        except ExtractError:
-            e = sys.exc_info()[1]
-            if self.errorlevel > 1:
-                raise
-            else:
-                self._dbg(1, "tarfile: %s" % e)
-
-
-def main(argv, version=DEFAULT_VERSION):
-    """Install or upgrade setuptools and EasyInstall"""
-    tarball = download_setuptools()
-    _install(tarball)
-
-
-if __name__ == '__main__':
-    main(sys.argv[1:])
diff -rupN a/.gitignore b/.gitignore
--- a/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ b/.gitignore	2013-06-10 17:52:22.000000000 +0200
@@ -0,0 +1,13 @@
+*~
+build
+siteconf.py
+Makefile
+.*.swp
+tags
+dist
+MANIFEST
+*.pyc
+*.egg-info
+*.so
+*.pyd
+setuptools.pth
diff -rupN a/MANIFEST.in b/MANIFEST.in
--- a/MANIFEST.in	2009-10-15 20:15:04.000000000 +0200
+++ b/MANIFEST.in	2013-06-10 17:52:22.000000000 +0200
@@ -4,7 +4,6 @@ include src/wrapper/common.hpp
 include test/tagrename
 include LICENSE
 
-include distribute_setup.py
 include configure.py
 include Makefile.in
 include aksetup_helper.py
diff -rupN a/PKG-INFO b/PKG-INFO
--- a/PKG-INFO	2012-12-27 14:57:26.000000000 +0100
+++ b/PKG-INFO	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-Metadata-Version: 1.1
-Name: tagpy
-Version: 2013.1
-Summary: Python Bindings for TagLib
-Home-page: http://mathema.tician.de/software/tagpy
-Author: Andreas Kloeckner
-Author-email: inform@tiker.net
-License: MIT
-Description: 
-                  TagPy is a set of Python bindings for Scott Wheeler's 
-                  `TagLib <http://developer.kde.org/~wheeler/taglib.html>`_. 
-                  It builds upon `Boost.Python <http://www.boost.org/libs/python/doc/>`_, 
-                  a wrapper generation library which is part of the renowned Boost 
-                  set of C++ libraries.
-        
-                  Just like TagLib, TagPy can:
-        
-                  * read and write ID3 tags of version 1 and 2, with many supported frame types
-                    for version 2 (in MPEG Layer 2 and MPEG Layer 3, FLAC and MPC),
-                  * access Xiph Comments in Ogg Vorbis Files and Ogg Flac Files,
-                  * access APE tags in Musepack and MP3 files.
-        
-                  All these features have their own specific interfaces, but 
-                  TagLib's generic tag reading and writing mechanism is also 
-                  supported. It comes with a bunch of examples.
-                  
-Platform: UNKNOWN
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Natural Language :: English
-Classifier: Operating System :: OS Independent
-Classifier: Operating System :: POSIX
-Classifier: Operating System :: Unix
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Topic :: Multimedia :: Sound/Audio
-Classifier: Topic :: Multimedia :: Sound/Audio :: CD Audio :: CD Ripping
-Classifier: Topic :: Multimedia :: Sound/Audio :: Editors
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Classifier: Topic :: Utilities
diff -rupN a/README.md b/README.md
--- a/README.md	1970-01-01 01:00:00.000000000 +0100
+++ b/README.md	2013-06-10 17:52:22.000000000 +0200
@@ -0,0 +1,147 @@
+TagPy
+=====
+
+TagPy is a a set of Python bindings for Scott Wheeler's TagLib
+[1](http://developer.kde.org/~wheeler/taglib.html). It builds upon Boost.Python
+[2](http://www.boost.org/libs/python/doc/), a wrapper generation library which
+is part of the Boost set of C++ libraries [3](http://www.boost.org). It has its
+own web site [4](http://mathema.tician.de/software/tagpy).
+
+Just like TagLib, TagPy can:
+
+- read and write ID3 tags of version 1 and 2, with many supported frame types
+  for version 2 (in MPEG Layer 2 and MPEG Layer 3, FLAC and MPC),
+- access Xiph Comments in Ogg Vorbis Files and Ogg Flac Files,
+- access APE tags in Musepack and MP3 files.
+
+All these have their own specific interfaces, but TagLib's generic tag
+reading and writing mechanism is also supported. 
+
+You can find examples in the test/ directory.
+
+Andreas Kloeckner <inform@tiker.net>
+
+Acknowledgments
+===============
+
+- Andreas Hemel <debian-bugs@daishan.de> sent a patch for a crash bug.
+- Michal Čihař <nijel@debian.org> maintains the Debian package.
+- Christoph Burgmer wrote the initial version of the new Python-only
+  FileRef.
+- Lars Wendler forwarded a patch from a Gentoo user.
+- [hobophobe on github](https://github.com/hobophobe/tagpy) ported
+  TagPy to Python 3.
+- Keith Packard wrote a UCS4 to UTF8 routine that I shamelessly stole.
+
+  Here's his copyright:
+
+  > Copyright © 2000 Keith Packard
+  >
+  > Permission to use, copy, modify, distribute, and sell this software and its
+  > documentation for any purpose is hereby granted without fee, provided that
+  > the above copyright notice appear in all copies and that both that
+  > copyright notice and this permission notice appear in supporting
+  > documentation, and that the name of Keith Packard not be used in
+  > advertising or publicity pertaining to distribution of the software without
+  > specific, written prior permission.  Keith Packard makes no
+  > representations about the suitability of this software for any purpose.  It
+  > is provided "as is" without express or implied warranty.
+  >
+  > KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+  > INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+  > EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+  > CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+  > DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+  > TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+  > PERFORMANCE OF THIS SOFTWARE.
+
+
+Building TagPy
+==============
+
+Step 0: Verifying that you have the right dependencies
+------------------------------------------------------
+
+TagPy works for me with
+
+- TagLib 1.4
+- Boost.Python 1.33
+- gcc 4.0
+
+I have reason to believe that slightly older versions of gcc and 
+Boost.Python should be fine, but the 1.4 requirement for TagLib is
+firm. Anything newer is also ok.
+
+Step 1: Installing Boost.Python
+-------------------------------
+
+In Debian, it suffices to do "aptitude install libboost-python-dev".
+The distribution is preconfigured for this case. You may skip to step
+2.
+
+For other distributions, check [this
+howto](http://wiki.tiker.net/BoostInstallationHowto).
+
+Step 2: Installing TagLib
+-------------------------
+
+In Debian, it suffices to do "aptitude install libtag1-dev".  The distribution
+is preconfigured for this case. You may skip to step 3.
+
+Install TagLib from its homepage, using the usual
+
+    configure; make; make install
+
+For details, you may consult the file `INSTALL' in the TagLib distribution.
+
+Step 3: Installing TagPy
+------------------------
+
+If necessary, edit the file `setup.py', namely the section labelled
+"USER CUSTOMIZABLE SECTION" to make sure the compiler will find your
+installations of Boost and TagLib.
+
+Then, run 
+
+    python setup.py build
+
+After a little wait, TagPy should finish building (if not, try and
+go back to tweaking `setup.py', depending on the error message).
+
+Finally, typing
+
+    su -c "python setup.py install"
+
+will complete the installation. 
+
+Congratulations! You are now ready to use TagPy.
+
+Using TagPy
+===========
+
+Using TagPy is as simple as this:
+
+    >>> import tagpy
+    >>> f = tagpy.FileRef("la.mp3")
+    >>> f.tag().artist
+    u'Andreas'
+
+The `test/` directory contains a few more examples. 
+
+In general, TagPy duplicates the TagLib API, with a few notable
+exceptions:
+
+- Namespaces (i.e. Python modules) are spelled in lower case.
+  For example, `TagLib::Ogg::Vorbis` is now `taglib.ogg.vorbis`.
+
+- Enumerations form their own scope and are not part of any
+  enclosing class scope, if any.
+
+  For example, the value `TagLib::String::UTF16BE` from the 
+  enum `TagLib::String::Type` is now `tagpy.StringType.UTF16BE`.
+
+- `TagLib::String` objects are mapped to and expected as Python
+  unicode objects.
+
+- `TagLib::ByteVector` objects are mapped to regular Python
+  string objects.
diff -rupN a/README.rst b/README.rst
--- a/README.rst	1970-01-01 01:00:00.000000000 +0100
+++ b/README.rst	2013-06-10 17:52:22.000000000 +0200
@@ -0,0 +1,16 @@
+TagPy is a set of Python bindings for Scott Wheeler's 
+`TagLib <http://developer.kde.org/~wheeler/taglib.html>`_. 
+It builds upon `Boost.Python <http://www.boost.org/libs/python/doc/>`_, 
+a wrapper generation library which is part of the renowned Boost 
+set of C++ libraries.
+
+Just like TagLib, TagPy can:
+
+* read and write ID3 tags of version 1 and 2, with many supported frame types
+  for version 2 (in MPEG Layer 2 and MPEG Layer 3, FLAC and MPC),
+* access Xiph Comments in Ogg Vorbis Files and Ogg Flac Files,
+* access APE tags in Musepack and MP3 files.
+
+All these features have their own specific interfaces, but 
+TagLib's generic tag reading and writing mechanism is also 
+supported. It comes with a bunch of examples.
diff -rupN a/setup.cfg b/setup.cfg
--- a/setup.cfg	2012-12-27 14:57:26.000000000 +0100
+++ b/setup.cfg	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-[egg_info]
-tag_build = 
-tag_date = 0
-tag_svn_revision = 0
-
diff -rupN a/setup.py b/setup.py
--- a/setup.py	2012-12-25 20:38:33.000000000 +0100
+++ b/setup.py	2013-06-10 17:52:22.000000000 +0200
@@ -9,7 +9,7 @@
 # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 # copies of the Software, and to permit persons to whom the Software is
 # furnished to do so, subject to the following conditions:
-# 
+#
 # The above copyright notice and this permission notice shall be included in
 # all copies or substantial portions of the Software.
 
@@ -22,10 +22,8 @@
 # SOFTWARE.
 
 
-
-
 def get_config_schema():
-    from aksetup_helper import ConfigSchema, Option, \
+    from aksetup_helper import ConfigSchema, \
             IncludeDir, LibraryDir, Libraries, BoostLibraries, \
             Switch, StringListOption, make_boost_base_options
 
@@ -36,15 +34,12 @@ def get_config_schema():
         LibraryDir("TAGLIB", []),
         Libraries("TAGLIB", ["tag"]),
 
-        StringListOption("CXXFLAGS", [], 
+        StringListOption("CXXFLAGS", [],
             help="Any extra C++ compiler options to include"),
         ])
 
 
-
-
 def main():
-    import glob
     from aksetup_helper import hack_distutils, get_config, setup, Extension
 
     hack_distutils()
@@ -57,59 +52,42 @@ def main():
     setup(name="tagpy",
           version="2013.1",
           description="Python Bindings for TagLib",
-          long_description="""
-          TagPy is a set of Python bindings for Scott Wheeler's 
-          `TagLib <http://developer.kde.org/~wheeler/taglib.html>`_. 
-          It builds upon `Boost.Python <http://www.boost.org/libs/python/doc/>`_, 
-          a wrapper generation library which is part of the renowned Boost 
-          set of C++ libraries.
-
-          Just like TagLib, TagPy can:
-
-          * read and write ID3 tags of version 1 and 2, with many supported frame types
-            for version 2 (in MPEG Layer 2 and MPEG Layer 3, FLAC and MPC),
-          * access Xiph Comments in Ogg Vorbis Files and Ogg Flac Files,
-          * access APE tags in Musepack and MP3 files.
-
-          All these features have their own specific interfaces, but 
-          TagLib's generic tag reading and writing mechanism is also 
-          supported. It comes with a bunch of examples.
-          """,
+          long_description=open("README.rst", "rt").read(),
           author="Andreas Kloeckner",
           author_email="inform@tiker.net",
           classifiers=
-          [ "Development Status :: 5 - Production/Stable",
-            "Intended Audience :: Developers",
-            "License :: OSI Approved :: MIT License",
-            "Natural Language :: English",
-            "Operating System :: OS Independent",
-            "Operating System :: POSIX",
-            "Operating System :: Unix",
-            "Programming Language :: Python",
-            "Programming Language :: Python :: 3",
-            "Topic :: Multimedia :: Sound/Audio",
-            "Topic :: Multimedia :: Sound/Audio :: CD Audio :: CD Ripping",
-            "Topic :: Multimedia :: Sound/Audio :: Editors",
-            "Topic :: Software Development :: Libraries :: Python Modules",
-            "Topic :: Utilities"],
-          license = "MIT",
+          [
+              "Development Status :: 5 - Production/Stable",
+              "Intended Audience :: Developers",
+              "License :: OSI Approved :: MIT License",
+              "Natural Language :: English",
+              "Operating System :: OS Independent",
+              "Operating System :: POSIX",
+              "Operating System :: Unix",
+              "Programming Language :: Python",
+              "Programming Language :: Python :: 3",
+              "Topic :: Multimedia :: Sound/Audio",
+              "Topic :: Multimedia :: Sound/Audio :: CD Audio :: CD Ripping",
+              "Topic :: Multimedia :: Sound/Audio :: Editors",
+              "Topic :: Software Development :: Libraries :: Python Modules",
+              "Topic :: Utilities"],
+          license="MIT",
 
           url="http://mathema.tician.de/software/tagpy",
           packages=["tagpy", "tagpy.ogg"],
-          ext_modules=[ Extension("_tagpy", 
-                                  ["src/wrapper/basics.cpp", 
-                                   "src/wrapper/id3.cpp",
-                                   "src/wrapper/rest.cpp"],
-                                  include_dirs=INCLUDE_DIRS,
-                                  library_dirs=LIBRARY_DIRS,
-                                  libraries=LIBRARIES,
-                                  extra_compile_args=conf["CXXFLAGS"],
-                                  ),
+          ext_modules=[
+              Extension("_tagpy",
+                  ["src/wrapper/basics.cpp",
+                      "src/wrapper/id3.cpp",
+                      "src/wrapper/rest.cpp"],
+                  include_dirs=INCLUDE_DIRS,
+                  library_dirs=LIBRARY_DIRS,
+                  libraries=LIBRARIES,
+                  extra_compile_args=conf["CXXFLAGS"],
+                  ),
                         ]
           )
 
 
-
-
 if __name__ == '__main__':
     main()
diff -rupN a/tagpy.egg-info/dependency_links.txt b/tagpy.egg-info/dependency_links.txt
--- a/tagpy.egg-info/dependency_links.txt	2012-12-27 14:57:26.000000000 +0100
+++ b/tagpy.egg-info/dependency_links.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-
diff -rupN a/tagpy.egg-info/PKG-INFO b/tagpy.egg-info/PKG-INFO
--- a/tagpy.egg-info/PKG-INFO	2012-12-27 14:57:26.000000000 +0100
+++ b/tagpy.egg-info/PKG-INFO	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-Metadata-Version: 1.1
-Name: tagpy
-Version: 2013.1
-Summary: Python Bindings for TagLib
-Home-page: http://mathema.tician.de/software/tagpy
-Author: Andreas Kloeckner
-Author-email: inform@tiker.net
-License: MIT
-Description: 
-                  TagPy is a set of Python bindings for Scott Wheeler's 
-                  `TagLib <http://developer.kde.org/~wheeler/taglib.html>`_. 
-                  It builds upon `Boost.Python <http://www.boost.org/libs/python/doc/>`_, 
-                  a wrapper generation library which is part of the renowned Boost 
-                  set of C++ libraries.
-        
-                  Just like TagLib, TagPy can:
-        
-                  * read and write ID3 tags of version 1 and 2, with many supported frame types
-                    for version 2 (in MPEG Layer 2 and MPEG Layer 3, FLAC and MPC),
-                  * access Xiph Comments in Ogg Vorbis Files and Ogg Flac Files,
-                  * access APE tags in Musepack and MP3 files.
-        
-                  All these features have their own specific interfaces, but 
-                  TagLib's generic tag reading and writing mechanism is also 
-                  supported. It comes with a bunch of examples.
-                  
-Platform: UNKNOWN
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Natural Language :: English
-Classifier: Operating System :: OS Independent
-Classifier: Operating System :: POSIX
-Classifier: Operating System :: Unix
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Topic :: Multimedia :: Sound/Audio
-Classifier: Topic :: Multimedia :: Sound/Audio :: CD Audio :: CD Ripping
-Classifier: Topic :: Multimedia :: Sound/Audio :: Editors
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Classifier: Topic :: Utilities
diff -rupN a/tagpy.egg-info/SOURCES.txt b/tagpy.egg-info/SOURCES.txt
--- a/tagpy.egg-info/SOURCES.txt	2012-12-27 14:57:26.000000000 +0100
+++ b/tagpy.egg-info/SOURCES.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-LICENSE
-MANIFEST.in
-Makefile.in
-README_SETUP.txt
-aksetup_helper.py
-configure.py
-distribute_setup.py
-setup.py
-src/wrapper/basics.cpp
-src/wrapper/common.hpp
-src/wrapper/id3.cpp
-src/wrapper/rest.cpp
-tagpy/__init__.py
-tagpy/ape.py
-tagpy/flac.py
-tagpy/id3v1.py
-tagpy/id3v2.py
-tagpy/mpc.py
-tagpy/mpeg.py
-tagpy.egg-info/PKG-INFO
-tagpy.egg-info/SOURCES.txt
-tagpy.egg-info/dependency_links.txt
-tagpy.egg-info/top_level.txt
-tagpy/ogg/__init__.py
-tagpy/ogg/flac.py
-tagpy/ogg/vorbis.py
-test/deb-bug-438556.py
-test/la.flac
-test/la.mp3
-test/la.ogg
-test/mp3-framedumper.py
-test/tagprinter.py
-test/tagrename
\ Pas de fin de ligne à la fin du fichier
diff -rupN a/tagpy.egg-info/top_level.txt b/tagpy.egg-info/top_level.txt
--- a/tagpy.egg-info/top_level.txt	2012-12-27 14:57:26.000000000 +0100
+++ b/tagpy.egg-info/top_level.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-tagpy
-_tagpy
